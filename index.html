<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>HexCube — View Only</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Syne:wght@600;700;800&display=swap" rel="stylesheet">
<style>
:root{
  --primary: #00D9FF;
  --primary-dark: #00A3C7;
  --secondary: #FF3366;
  --bg: #0A0E14;
  --bg-light: #141920;
  --surface: #1C2128;
  --surface-hover: #252C35;
  --border: rgba(255,255,255,0.06);
  --text: #E6EDF3;
  --text-muted: #7D8590;
  --success: #3FB950;
  --danger: #F85149;
  --warning: #D29922;
  --shadow: 0 8px 32px rgba(0,0,0,0.4);
  --shadow-lg: 0 20px 60px rgba(0,0,0,0.6);
  --radius: 8px;
  --radius-lg: 12px;
  --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  --font-display: 'Syne', sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
}

/* Light theme */
body.light-theme {
  --bg: #F5F7FA;
  --bg-light: #FFFFFF;
  --surface: #FFFFFF;
  --surface-hover: #F0F2F5;
  --border: rgba(0,0,0,0.08);
  --text: #1A1F36;
  --text-muted: #6B7280;
  --shadow: 0 8px 32px rgba(0,0,0,0.08);
  --shadow-lg: 0 20px 60px rgba(0,0,0,0.12);
}

body.light-theme canvas {
  background: #F5F7FA !important;
}

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
  font-family: var(--font-mono);
  background: var(--bg);
  color: var(--text);
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Canvas wrapper */
#canvas-container {
  position: fixed;
  inset: 0;
  z-index: 1;
  transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

#canvas-container.hidden {
  transform: translateX(-100%);
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-display);
  font-weight: 800;
  letter-spacing: -0.02em;
}

/* Glassmorphic panel base */
.panel {
  background: rgba(28, 33, 40, 0.85);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow);
}

/* Header */
#header {
  position: fixed;
  top: 20px;
  left: 20px;
  right: 20px;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px 20px;
  background: rgba(28, 33, 40, 0.7);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow);
}

#logo {
  font-family: var(--font-display);
  font-size: 1.25rem;
  font-weight: 800;
  background: linear-gradient(135deg, var(--primary), var(--secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  letter-spacing: -0.03em;
}

#header-controls {
  margin-left: auto;
  display: flex;
  gap: 8px;
  align-items: center;
}

/* Buttons */
.btn {
  padding: 10px 16px;
  border: none;
  border-radius: var(--radius);
  font-family: var(--font-mono);
  font-size: 0.875rem;
  font-weight: 700;
  cursor: pointer;
  transition: var(--transition);
  white-space: nowrap;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.btn-primary {
  background: var(--primary);
  color: var(--bg);
  box-shadow: 0 4px 16px rgba(0, 217, 255, 0.3);
}

.btn-primary:hover {
  background: var(--primary-dark);
  transform: translateY(-1px);
  box-shadow: 0 6px 20px rgba(0, 217, 255, 0.4);
}

.btn-primary:active {
  transform: translateY(0);
}

.btn-secondary {
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
}

.btn-secondary:hover {
  background: var(--surface-hover);
}

.btn-danger {
  background: var(--danger);
  color: white;
}

.btn-success {
  background: var(--success);
  color: white;
}

.btn-icon {
  padding: 10px;
  background: var(--surface);
  border: 1px solid var(--border);
}

.btn-icon:hover {
  background: var(--surface-hover);
  border-color: var(--primary);
}

/* Left sidebar - Marker list */
#sidebar {
  position: fixed;
  left: 20px;
  top: 100px;
  width: 340px;
  max-height: calc(100vh - 120px);
  z-index: 90;
  display: flex;
  flex-direction: column;
  padding: 20px;
  background: rgba(28, 33, 40, 0.85);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

#sidebar.collapsed {
  transform: translateX(calc(-100% - 20px));
}

#sidebar h3 {
  margin-bottom: 16px;
  font-size: 1.125rem;
}

#search-box {
  width: 100%;
  padding: 10px 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  color: var(--text);
  font-family: var(--font-mono);
  font-size: 0.875rem;
  transition: var(--transition);
}

#search-box:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(0, 217, 255, 0.1);
}

#marker-list {
  flex: 1;
  margin-top: 16px;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 4px;
}

#marker-list::-webkit-scrollbar {
  width: 6px;
}

#marker-list::-webkit-scrollbar-track {
  background: transparent;
}

#marker-list::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 3px;
}

#marker-list::-webkit-scrollbar-thumb:hover {
  background: var(--primary);
}

.marker-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  margin-bottom: 8px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  cursor: pointer;
  transition: var(--transition);
}

.marker-item:hover {
  background: var(--surface-hover);
  border-color: var(--primary);
  transform: translateX(4px);
}

.marker-dot {
  width: 12px;
  height: 12px;
  border-radius: 3px;
  flex-shrink: 0;
  box-shadow: 0 0 12px currentColor;
}

.marker-name {
  flex: 1;
  font-size: 0.875rem;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.marker-id {
  font-size: 0.75rem;
  color: var(--text-muted);
}

/* Control pad */
#control-pad {
  position: fixed;
  left: 20px;
  bottom: 20px;
  z-index: 90;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: rgba(28, 33, 40, 0.85);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  transition: opacity 0.2s ease;
}

#control-pad-label {
  font-size: 0.7rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-right: 4px;
}

#pad-grid {
  display: flex;
  gap: 4px;
}

.pad-btn {
  width: 32px;
  height: 32px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  color: var(--text);
  font-size: 1rem;
  cursor: pointer;
  transition: var(--transition);
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
}

.pad-btn:hover {
  background: var(--surface-hover);
  border-color: var(--primary);
}

.pad-btn:active {
  background: var(--primary);
  color: var(--bg);
}

#pad-hint {
  display: none;
}

/* Action buttons (bottom right) */
#action-buttons {
  position: fixed;
  right: 20px;
  bottom: 20px;
  z-index: 90;
  display: flex;
  flex-direction: column;
  gap: 12px;
  align-items: flex-end;
}

#place-mode-controls {
  display: none;
  gap: 8px;
}

#place-mode-controls.active {
  display: flex;
}

/* Editor panel (right side) */
#editor-panel {
  position: fixed;
  right: -420px;
  top: 100px;
  width: 400px;
  max-height: calc(100vh - 120px);
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 24px;
  background: rgba(28, 33, 40, 0.95);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg) 0 0 var(--radius-lg);
  box-shadow: var(--shadow-lg);
  transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  overflow-y: auto;
}

#editor-panel.open {
  right: 20px;
}

#editor-panel h3 {
  font-size: 1.25rem;
  display: flex;
  align-items: center;
  gap: 8px;
}

#editor-id {
  font-size: 0.875rem;
  color: var(--text-muted);
  font-weight: 400;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.form-label {
  font-size: 0.75rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-weight: 700;
}

.form-input {
  padding: 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  color: var(--text);
  font-family: var(--font-mono);
  font-size: 0.875rem;
  transition: var(--transition);
}

.form-input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(0, 217, 255, 0.1);
}

.color-picker-group {
  display: flex;
  gap: 12px;
  align-items: center;
}

#editor-color {
  width: 60px;
  height: 48px;
  border: 2px solid var(--border);
  border-radius: var(--radius);
  cursor: pointer;
  transition: var(--transition);
}

#editor-color:hover {
  border-color: var(--primary);
}

.color-info {
  flex: 1;
}

#editor-color-hex {
  font-size: 1rem;
  font-weight: 700;
  font-family: var(--font-mono);
  margin-bottom: 4px;
}

#editor-actions {
  display: flex;
  gap: 8px;
  margin-top: auto;
  padding-top: 20px;
  border-top: 1px solid var(--border);
}

/* Settings dropdown */
#settings-dropdown {
  position: relative;
}

#settings-menu {
  display: none;
  position: absolute;
  top: calc(100% + 8px);
  right: 0;
  width: 200px;
  padding: 8px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
}

#settings-menu.open {
  display: block;
}

.settings-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 12px;
  border-radius: var(--radius);
  cursor: pointer;
  transition: var(--transition);
}

.settings-item:hover {
  background: var(--surface-hover);
}

.settings-label {
  font-size: 0.875rem;
}

/* Toggle switch */
.toggle {
  position: relative;
  width: 40px;
  height: 20px;
  background: var(--border);
  border-radius: 10px;
  transition: var(--transition);
  cursor: pointer;
}

.toggle::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 16px;
  height: 16px;
  background: var(--text);
  border-radius: 50%;
  transition: var(--transition);
}

.toggle.active {
  background: var(--primary);
}

.toggle.active::after {
  transform: translateX(20px);
}

/* Tooltip */
#tooltip {
  position: fixed;
  pointer-events: none;
  display: none;
  z-index: 1000;
  padding: 8px 12px;
  background: var(--bg-light);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 0.875rem;
  box-shadow: var(--shadow);
  max-width: 200px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Status indicator */
#status-indicator {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 95;
  padding: 12px 20px;
  background: rgba(28, 33, 40, 0.95);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow);
  font-size: 0.875rem;
  display: none;
  align-items: center;
  gap: 12px;
}

#status-indicator.active {
  display: flex;
}

.status-icon {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--primary);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* Help overlay */
#help-overlay {
  position: fixed;
  inset: 0;
  z-index: 200;
  background: rgba(10, 14, 20, 0.9);
  backdrop-filter: blur(8px);
  display: none;
  align-items: center;
  justify-content: center;
  padding: 40px;
}

#help-overlay.active {
  display: flex;
}

#help-content {
  max-width: 600px;
  width: 100%;
  padding: 32px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
}

#help-content h2 {
  margin-bottom: 24px;
  font-size: 1.5rem;
}

.help-section {
  margin-bottom: 20px;
}

.help-section h4 {
  margin-bottom: 8px;
  font-size: 1rem;
  color: var(--primary);
}

.help-section p {
  font-size: 0.875rem;
  line-height: 1.6;
  color: var(--text-muted);
}

.keyboard-shortcuts {
  display: grid;
  gap: 8px;
  margin-top: 12px;
}

.shortcut-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  background: var(--bg);
  border-radius: var(--radius);
}

.shortcut-key {
  padding: 4px 8px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: var(--font-mono);
  font-size: 0.75rem;
}

/* URL Viewer */
#url-viewer {
  position: fixed;
  inset: 0;
  z-index: 150;
  background: var(--bg);
  display: flex;
  flex-direction: column;
  transform: translateX(100%);
  transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

#url-viewer.active {
  transform: translateX(0);
}

#viewer-header {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 20px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  z-index: 151;
}

#viewer-url-display {
  flex: 1;
  font-family: var(--font-mono);
  font-size: 0.875rem;
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#url-iframe {
  flex: 1;
  width: 100%;
  border: none;
  background: white;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
  #sidebar {
    width: 300px;
  }
  
  #editor-panel {
    width: 340px;
  }
}

@media (max-width: 768px) {
  #header {
    padding: 12px 16px;
  }
  
  #logo {
    font-size: 1rem;
  }
  
  #sidebar {
    left: 10px;
    top: 80px;
    width: 280px;
  }
  
  #control-pad {
    left: 10px;
    bottom: 10px;
    width: 120px;
  }
  
  #action-buttons {
    right: 10px;
    bottom: 10px;
  }
  
  #editor-panel {
    width: calc(100% - 20px);
    right: -100%;
  }
  
  #editor-panel.open {
    right: 10px;
  }
}

/* Loading state */
.loading {
  opacity: 0.5;
  pointer-events: none;
}

/* Animations */
@keyframes slideInLeft {
  from {
    transform: translateX(-20px);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideInRight {
  from {
    transform: translateX(20px);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.marker-item {
  animation: slideInLeft 0.2s ease-out;
}

#editor-panel.open {
  animation: slideInRight 0.35s cubic-bezier(0.4, 0, 0.2, 1);
}
</style>
</head>
<body>

<!-- Header -->
<header id="header">
  <div id="logo">HEXCUBE</div>
  <div id="header-controls">
    <button class="btn btn-icon" id="toggle-sidebar" title="Toggle sidebar" aria-label="Toggle sidebar">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
        <path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </button>
    <button class="btn btn-icon" id="help-btn" title="Help" aria-label="Help">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
        <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
        <text x="8" y="12" text-anchor="middle" fill="currentColor" font-size="12" font-weight="bold" font-family="system-ui">?</text>
      </svg>
    </button>
    <div id="settings-dropdown">
      <button class="btn btn-icon" id="settings-btn" title="Settings" aria-label="Settings">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
          <circle cx="8" cy="8" r="2" stroke="currentColor" stroke-width="1.5"/>
          <path d="M8 1v2M8 13v2M15 8h-2M3 8H1M13.5 13.5l-1.5-1.5M4 4L2.5 2.5M13.5 2.5L12 4M4 12l-1.5 1.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
      </button>
      <div id="settings-menu" aria-hidden="true">
        <div class="settings-item" id="theme-toggle-item">
          <span class="settings-label">Light theme</span>
          <div class="toggle" id="theme-toggle" role="switch" aria-checked="false"></div>
        </div>
        <div class="settings-item" id="grid-toggle-item">
          <span class="settings-label">Grid</span>
          <div class="toggle" id="grid-toggle" role="switch" aria-checked="false"></div>
        </div>
        <div class="settings-item" id="auto-rotate-item">
          <span class="settings-label">Auto-rotate</span>
          <div class="toggle" id="auto-rotate-toggle" role="switch" aria-checked="false"></div>
        </div>
      </div>
    </div>
  </div>
</header>

<!-- Sidebar -->
<aside id="sidebar">
  <h3>Units</h3>
  <input 
    type="search" 
    id="search-box" 
    placeholder="Search units..." 
    aria-label="Search units"
  />
  <div id="marker-list" role="list"></div>
  <div style="margin-top: 12px; font-size: 0.75rem; color: var(--text-muted); line-height: 1.5;">
    Click <strong style="color: var(--primary);">+ Add Marker</strong> to place markers on cube faces. Use arrow keys or control pad to rotate.
  </div>
</aside>

<!-- Control pad -->
<div id="control-pad">
  <div id="control-pad-label">Rotate</div>
  <div id="pad-grid">
    <button class="pad-btn" id="pad-left" aria-label="Rotate left">←</button>
    <button class="pad-btn" id="pad-up" aria-label="Rotate up">↑</button>
    <button class="pad-btn" id="pad-down" aria-label="Rotate down">↓</button>
    <button class="pad-btn" id="pad-right" aria-label="Rotate right">→</button>
  </div>
</div>

<!-- Contact info + Demo Add Unit for client view -->
<div id="action-buttons">
  <div id="place-mode-controls">
    <button class="btn btn-success" id="confirm-place">
      <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
        <path d="M2 7l4 4 6-8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      Confirm
    </button>
    <button class="btn btn-danger" id="cancel-place">
      <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
        <path d="M2 2l10 10M12 2L2 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
      Cancel
    </button>
  </div>
  <button class="btn btn-primary" id="add-marker-btn">
    <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
      <path d="M7 2v10M2 7h10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    </svg>
    Add Unit (Demo)
  </button>
  <div style="max-width: 280px; padding: 16px 20px; background: rgba(28, 33, 40, 0.9); backdrop-filter: blur(20px); border: 1px solid var(--border); border-radius: var(--radius-lg); box-shadow: var(--shadow); margin-top: 12px;">
    <div style="font-size: 0.875rem; line-height: 1.6; color: var(--text); margin-bottom: 12px;">
      <strong style="color: var(--primary); display: block; margin-bottom: 8px;">Want to create a permanent Unit?</strong>
      Contact <strong>Kobus Liebenberg</strong>:
    </div>
    <div style="font-size: 0.8rem; font-family: var(--font-mono); color: var(--text-muted); margin-bottom: 8px;">
      Email: <a href="mailto:kobus.email@gmail.com" style="color: var(--primary); text-decoration: none;">kobus.email@gmail.com</a>
    </div>
    <div style="font-size: 0.8rem; font-family: var(--font-mono); color: var(--text-muted); margin-bottom: 12px;">
      Phone: <a href="tel:+27661218440" style="color: var(--primary); text-decoration: none;">+27 66 121 8440</a>
    </div>
    <div style="font-size: 0.75rem; color: var(--text-muted); font-style: italic; padding-top: 8px; border-top: 1px solid var(--border);">
      Thank you for your ongoing support. We are building the future cube by cube.
    </div>
  </div>
</div>

<!-- Editor panel -->
<aside id="editor-panel" aria-hidden="true">
  <!-- Collapsed quick view -->
  <div id="editor-collapsed">
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
      <h3 style="flex: 1; margin: 0; font-size: 1.125rem;">
        <span id="editor-name-collapsed">Unit</span>
      </h3>
      <button class="btn btn-icon" id="expand-editor-btn" title="Edit details (demo)" aria-label="Expand editor">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
          <path d="M10 1l3 3-7 7H3v-3l7-7z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M8.5 2.5l2 2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button class="btn btn-icon" id="close-editor-collapsed-btn" aria-label="Close">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
          <path d="M2 2l10 10M12 2L2 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </button>
    </div>
    
    <div id="marker-preview">
      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
        <div id="preview-color-dot" style="width: 16px; height: 16px; border-radius: 4px; box-shadow: 0 0 8px currentColor;"></div>
        <span id="preview-id" style="font-size: 0.875rem; color: var(--text-muted); font-family: var(--font-mono);"></span>
      </div>
      <div id="preview-url" style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 16px; word-break: break-all; font-family: var(--font-mono);"></div>
    </div>
    
    <button class="btn btn-primary" id="visit-url-btn" style="width: 100%;" disabled>
      <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
        <path d="M10 2h2v2M12 2L6 8M8 2h-6v10h10V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      Visit URL
    </button>
  </div>

  <!-- Expanded editor view -->
  <div id="editor-expanded" style="display: none; flex-direction: column; gap: 20px; height: 100%;">
    <div style="display: flex; align-items: center; gap: 12px;">
      <h3 style="flex: 1; margin: 0;">
        Edit Unit
        <span id="editor-id">#0</span>
      </h3>
      <button class="btn btn-icon" id="collapse-editor-btn" title="Collapse" aria-label="Collapse editor">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
          <path d="M13 7H8m0 0V2m0 5l5 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
    </div>

    <div class="form-group">
      <label class="form-label" for="editor-name">Name</label>
      <input 
        type="text" 
        id="editor-name" 
        class="form-input" 
        placeholder="Enter unit name..."
        aria-label="Unit name"
      />
    </div>

    <div class="form-group">
      <label class="form-label" for="editor-url">URL</label>
      <input 
        type="url" 
        id="editor-url" 
        class="form-input" 
        placeholder="https://example.com"
        aria-label="Unit URL"
      />
    </div>

    <div class="form-group">
      <label class="form-label">Color</label>
      <div class="color-picker-group">
        <input 
          type="color" 
          id="editor-color" 
          value="#00D9FF"
          aria-label="Unit color"
        />
        <div class="color-info">
          <div id="editor-color-hex">#00D9FF</div>
          <div class="form-label" style="text-transform: none;">Click to change</div>
        </div>
      </div>
    </div>

    <div class="form-group">
      <label class="form-label">Position</label>
      <button class="btn btn-secondary" id="move-marker-btn">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
          <path d="M7 2v10M2 7h10M4 4L2 2l2 2zM10 4l2-2-2 2zM4 10l-2 2 2-2zM10 10l2 2-2-2z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        Move Unit
      </button>
      <p class="form-label" style="text-transform: none; margin-top: 4px;">
        Click to choose a new position - unit moves instantly when you click a hex.
      </p>
    </div>

    <div id="editor-actions" style="margin-top: auto;">
      <button class="btn btn-primary" id="save-marker-btn" style="flex: 1;">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
          <path d="M11 13H3c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2h6l4 4v6c0 1.1-.9 2-2 2z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M9 13v-5H5v5M5 1v4h4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        Save
      </button>
      <button class="btn btn-danger" id="delete-marker-btn">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
          <path d="M2 4h10M5 4V2h4v2M11 4v8c0 1-1 2-2 2H5c-1 0-2-1-2-2V4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button class="btn btn-secondary" id="close-editor-btn">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
          <path d="M2 2l10 10M12 2L2 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </button>
    </div>
  </div>
</aside>

<!-- Status indicator -->
<div id="status-indicator">
  <div class="status-icon"></div>
  <span id="status-text">Ready</span>
</div>

<!-- Tooltip -->
<div id="tooltip" role="tooltip"></div>

<!-- Help overlay -->
<div id="help-overlay">
  <div id="help-content">
    <h2>HexCube Guide</h2>
    
    <div class="help-section">
      <h4>Demo Mode</h4>
      <p>Try adding units by clicking "+ Add Unit (Demo)". Your changes stay in this session only and won't be saved permanently. Contact Kobus to create permanent units!</p>
    </div>

    <div class="help-section">
      <h4>Viewing Units</h4>
      <p>Click any unit or select it from the sidebar to view its details. If it has a URL, click "Visit URL" to view it full-screen. Click "Back to Cube" to return.</p>
    </div>

    <div class="help-section">
      <h4>Navigation</h4>
      <p>Drag with your mouse to orbit freely. Use arrow keys or the control pad to flip the cube 90 degrees in any direction. Combine rotations to see all sides!</p>
    </div>

    <div class="help-section">
      <h4>Keyboard Shortcuts</h4>
      <div class="keyboard-shortcuts">
        <div class="shortcut-row">
          <span>Add unit (demo)</span>
          <kbd class="shortcut-key">A</kbd>
        </div>
        <div class="shortcut-row">
          <span>Toggle grid</span>
          <kbd class="shortcut-key">G</kbd>
        </div>
        <div class="shortcut-row">
          <span>Toggle sidebar</span>
          <kbd class="shortcut-key">S</kbd>
        </div>
        <div class="shortcut-row">
          <span>Flip cube</span>
          <kbd class="shortcut-key">← → ↑ ↓</kbd>
        </div>
        <div class="shortcut-row">
          <span>Help</span>
          <kbd class="shortcut-key">?</kbd>
        </div>
        <div class="shortcut-row">
          <span>Close panels</span>
          <kbd class="shortcut-key">ESC</kbd>
        </div>
      </div>
    </div>

    <button class="btn btn-primary" id="close-help-btn" style="margin-top: 24px; width: 100%;">
      Got it!
    </button>
  </div>
</div>

<!-- Canvas container -->
<div id="canvas-container"></div>

<!-- URL Viewer (slides in from right) -->
<div id="url-viewer" aria-hidden="true">
  <div id="viewer-header">
    <button class="btn btn-secondary" id="back-to-cube">
      <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
        <path d="M10 2L4 7l6 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      Back to Cube
    </button>
    <div id="viewer-url-display"></div>
    <button class="btn btn-icon" id="open-in-new-tab">
      <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
        <path d="M10 2h2v2M12 2L6 8M8 2h-6v10h10V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </div>
  <iframe id="url-iframe" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" allowfullscreen></iframe>
</div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
'use strict';

// ========================================
// HEXCUBE CLIENT VIEW - READ ONLY
// This version does not allow adding, editing, or deleting units
// ========================================

// ========================================
// EMBEDDED UNIT DATA
// Replace this array with your exported unit data
// ========================================
const EMBEDDED_MARKERS = [
  {
    "id": 8,
    "label": "Langebaan Nessie",
    "url": "https://www.langebaannessie.co.za/",
    "face": "+Y",
    "color": 14810880,
    "x": -0.33,
    "y": 1,
    "z": 0.1905255888325765
  },
  {
    "id": 10,
    "label": "Mykonos Carwash",
    "url": "https://solidstate872.github.io/mykonoscarwash/",
    "face": "+Y",
    "color": 55807,
    "x": 0,
    "y": 1,
    "z": -0.381051177665153
  },
  {
    "id": 11,
    "label": "Marc's Beachbar",
    "url": "https://solidstate872.github.io/marcsbeachbarpromo/",
    "face": "+Y",
    "color": 65365,
    "x": 0.33,
    "y": 1,
    "z": 0.1905255888325765
  }
];

// ========================================
// CONFIGURATION
// ========================================
const CONFIG = {
  GRID_RADIUS: 2,
  HEX_RADIUS: 0.22,
  CUBE_SIZE: 2,
  EXTRUDE_DEPTH: 0.02,
  STORAGE_KEY: 'hexcube_markers_v2',
  ROTATION_SPEED: Math.PI * 0.4,
  CAMERA_DISTANCE: 6,
  HOVER_DELAY: 300,
  AUTO_ROTATE_SPEED: 0.001,
};

const COLORS = {
  PRIMARY: 0x00D9FF,
  SECONDARY: 0xFF3366,
  SUCCESS: 0x3FB950,
  DANGER: 0xF85149,
  WARNING: 0xD29922,
  CUBE: 0x1C2128,
  GRID: 0x7D8590,
  BACKGROUND: 0x0A0E14,
};

// ========================================
// STATE MANAGEMENT
// ========================================
class AppState {
  constructor() {
    this.markers = [];
    this.nextId = 1;
    this.placementMode = false;
    this.placementLocked = false;
    this.moveMode = false;
    this.selectedPlacement = null;
    this.selectedMarker = null;
    this.rotationState = { x: 0, y: 0 };
    this.autoRotate = false;
    this.gridVisible = false;
    this.sidebarCollapsed = false;
    this.keysPressed = new Set();
    this.cubeAligned = false; // Track if cube has been reset to frontal view
  }

  addMarker(marker) {
    this.markers.push(marker);
    this.nextId = Math.max(this.nextId, marker.userData.id + 1);
  }

  removeMarker(marker) {
    const index = this.markers.indexOf(marker);
    if (index > -1) {
      this.markers.splice(index, 1);
    }
  }

  getMarkerById(id) {
    return this.markers.find(m => m.userData.id === id);
  }

  setPlacementMode(active) {
    this.placementMode = active;
    this.placementLocked = false;
    if (!active) {
      this.selectedPlacement = null;
    }
  }

  setMoveMode(active) {
    this.moveMode = active;
    this.placementLocked = false;
    if (!active) {
      this.selectedPlacement = null;
    }
  }

  setRotation(x, y) {
    this.rotationState.x = x * CONFIG.ROTATION_SPEED;
    this.rotationState.y = y * CONFIG.ROTATION_SPEED;
  }

  stopRotation() {
    this.rotationState.x = 0;
    this.rotationState.y = 0;
  }
}

const state = new AppState();

// ========================================
// SCENE SETUP
// ========================================
class SceneManager {
  constructor() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(COLORS.BACKGROUND);

    this.camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(3, 3, CONFIG.CAMERA_DISTANCE);

    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(this.renderer.domElement);

    this.setupLights();
    this.setupCube();
    this.setupControls();
    this.setupRaycaster();
    this.setupGhost();

    window.addEventListener('resize', () => this.onResize());
  }

  setupLights() {
    const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    this.scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
    keyLight.position.set(6, 8, 6);
    this.scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight.position.set(-6, -4, -6);
    this.scene.add(fillLight);
  }

  setupCube() {
    const geometry = new THREE.BoxGeometry(
      CONFIG.CUBE_SIZE,
      CONFIG.CUBE_SIZE,
      CONFIG.CUBE_SIZE
    );
    
    const material = new THREE.MeshStandardMaterial({
      color: COLORS.CUBE,
      roughness: 0.4,
      metalness: 0.1,
    });

    this.cube = new THREE.Mesh(geometry, material);
    this.scene.add(this.cube);

    // Add edges
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x00D9FF,
      opacity: 0.3,
      transparent: true,
    });
    const wireframe = new THREE.LineSegments(edges, lineMaterial);
    this.cube.add(wireframe);

    // Build grid
    this.buildGrid();
  }

  buildGrid() {
    this.gridGroup = new THREE.Group();
    const faceCenters = GeometryHelper.generateFaceCenters();

    const material = new THREE.LineBasicMaterial({
      color: COLORS.GRID,
      opacity: 0.15,
      transparent: true,
    });

    Object.keys(faceCenters).forEach(face => {
      faceCenters[face].forEach(center => {
        const points = [];
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          points.push(
            new THREE.Vector3(
              Math.cos(angle) * CONFIG.HEX_RADIUS,
              Math.sin(angle) * CONFIG.HEX_RADIUS,
              CONFIG.EXTRUDE_DEPTH / 2
            )
          );
        }

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.LineLoop(geometry, material);

        const normal = GeometryHelper.getFaceNormal(face);
        const quaternion = new THREE.Quaternion().setFromUnitVectors(
          new THREE.Vector3(0, 0, 1),
          normal.clone().normalize()
        );

        line.quaternion.copy(quaternion);
        line.position.copy(center);
        this.gridGroup.add(line);
      });
    });

    this.gridGroup.visible = false;
    this.cube.add(this.gridGroup);
  }

  setupControls() {
    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enablePan = false;
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.08;
    this.controls.target.set(0, 0, 0);
    this.controls.minDistance = 4;
    this.controls.maxDistance = 12;
  }

  setupRaycaster() {
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();
  }

  setupGhost() {
    this.ghost = MarkerFactory.createHexMesh(COLORS.PRIMARY);
    this.ghost.material = this.ghost.material.clone();
    this.ghost.material.transparent = true;
    this.ghost.material.opacity = 0.3;
    this.ghost.material.depthWrite = false;
    this.ghost.visible = false;
    this.cube.add(this.ghost);
  }

  setGridVisible(visible) {
    if (this.gridGroup) {
      this.gridGroup.visible = visible;
    }
  }

  updateTheme(isLight) {
    // Update scene background
    this.scene.background.setHex(isLight ? 0xF5F7FA : 0x0A0E14);
    
    // Update cube color
    this.cube.material.color.setHex(isLight ? 0xE5E7EB : 0x1C2128);
  }

  resetCubeRotation(callback) {
    // Reset cube to show a face perfectly square/flat facing camera
    // This means rotating to show a face straight-on (not corner-on)
    const duration = 500;
    const startRotation = {
      x: this.cube.rotation.x,
      y: this.cube.rotation.y,
      z: this.cube.rotation.z
    };

    // Standard frontal square view: slight tilt down, no side rotation
    const targetRotation = { 
      x: Math.PI / 8,  // Slight tilt for better perspective
      y: 0,            // Face straight-on
      z: 0 
    };

    const startTime = Date.now();

    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Ease out cubic
      const eased = 1 - Math.pow(1 - progress, 3);

      this.cube.rotation.x = startRotation.x + (targetRotation.x - startRotation.x) * eased;
      this.cube.rotation.y = startRotation.y + (targetRotation.y - startRotation.y) * eased;
      this.cube.rotation.z = startRotation.z + (targetRotation.z - startRotation.z) * eased;

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else if (callback) {
        callback();
      }
    };

    animate();
  }

  rotateCubeToDirection(direction) {
    // Just rotate the cube 90 degrees in the direction pressed
    // The cube will naturally show the next face flat-on
    
    const duration = 400;
    const startRotation = {
      x: this.cube.rotation.x,
      y: this.cube.rotation.y,
      z: this.cube.rotation.z
    };

    const targetRotation = {
      x: startRotation.x,
      y: startRotation.y,
      z: startRotation.z
    };

    // Add 90 degrees (PI/2) in the direction pressed
    switch(direction) {
      case 'up':
        targetRotation.x += Math.PI / 2;
        break;
      case 'down':
        targetRotation.x -= Math.PI / 2;
        break;
      case 'left':
        targetRotation.y += Math.PI / 2;
        break;
      case 'right':
        targetRotation.y -= Math.PI / 2;
        break;
    }

    const startTime = Date.now();

    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Ease out cubic
      const eased = 1 - Math.pow(1 - progress, 3);

      this.cube.rotation.x = startRotation.x + (targetRotation.x - startRotation.x) * eased;
      this.cube.rotation.y = startRotation.y + (targetRotation.y - startRotation.y) * eased;

      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };

    animate();
  }

  onResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  render() {
    this.renderer.render(this.scene, this.camera);
  }
}

// ========================================
// GEOMETRY HELPERS
// ========================================
class GeometryHelper {
  static generateFaceCenters() {
    const axialCoords = this.generateAxialCoords(CONFIG.GRID_RADIUS);
    const faceCenters = {
      '+Z': [], '-Z': [],
      '+X': [], '-X': [],
      '+Y': [], '-Y': []
    };

    const half = CONFIG.CUBE_SIZE / 2;

    axialCoords.forEach(({ q, r }) => {
      const pixel = this.axialToPixel(q, r);

      Object.keys(faceCenters).forEach(face => {
        const local = this.pixelToLocal(face, pixel.x, pixel.y);
        
        if (
          Math.abs(local.x) <= half + 0.0001 &&
          Math.abs(local.y) <= half + 0.0001 &&
          Math.abs(local.z) <= half + 0.0001
        ) {
          faceCenters[face].push(local);
        }
      });
    });

    return faceCenters;
  }

  static generateAxialCoords(radius) {
    const coords = [];
    for (let q = -radius; q <= radius; q++) {
      const r1 = Math.max(-radius, -q - radius);
      const r2 = Math.min(radius, -q + radius);
      for (let r = r1; r <= r2; r++) {
        coords.push({ q, r });
      }
    }
    return coords;
  }

  static axialToPixel(q, r) {
    const x = CONFIG.HEX_RADIUS * 1.5 * q;
    const y = CONFIG.HEX_RADIUS * Math.sqrt(3) * (r + q / 2);
    return { x, y };
  }

  static pixelToLocal(face, px, py) {
    const half = CONFIG.CUBE_SIZE / 2;
    
    switch (face) {
      case '+Z': return new THREE.Vector3(px, py, half);
      case '-Z': return new THREE.Vector3(-px, py, -half);
      case '+X': return new THREE.Vector3(half, py, -px);
      case '-X': return new THREE.Vector3(-half, py, px);
      case '+Y': return new THREE.Vector3(px, half, -py);
      case '-Y': return new THREE.Vector3(px, -half, py);
      default: return new THREE.Vector3(0, 0, 0);
    }
  }

  static getFaceNormal(face) {
    const normals = {
      '+Z': new THREE.Vector3(0, 0, 1),
      '-Z': new THREE.Vector3(0, 0, -1),
      '+X': new THREE.Vector3(1, 0, 0),
      '-X': new THREE.Vector3(-1, 0, 0),
      '+Y': new THREE.Vector3(0, 1, 0),
      '-Y': new THREE.Vector3(0, -1, 0)
    };
    return normals[face] || new THREE.Vector3(0, 0, 1);
  }

  static findFaceFromLocal(local) {
    const ax = Math.abs(local.x);
    const ay = Math.abs(local.y);
    const az = Math.abs(local.z);
    const max = Math.max(ax, ay, az);

    if (max === ax) return local.x > 0 ? '+X' : '-X';
    if (max === ay) return local.y > 0 ? '+Y' : '-Y';
    return local.z > 0 ? '+Z' : '-Z';
  }

  static findNearestCenter(face, point) {
    const faceCenters = this.generateFaceCenters();
    const centers = faceCenters[face] || [];
    
    if (centers.length === 0) return null;

    let nearest = null;
    let minDist = Infinity;

    centers.forEach(center => {
      const dist = center.distanceToSquared(point);
      if (dist < minDist) {
        minDist = dist;
        nearest = center;
      }
    });

    return nearest ? nearest.clone() : null;
  }
}

// ========================================
// MARKER FACTORY
// ========================================
class MarkerFactory {
  static createHexMesh(color = COLORS.PRIMARY) {
    const shape = new THREE.Shape();
    
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const x = Math.cos(angle) * CONFIG.HEX_RADIUS;
      const y = Math.sin(angle) * CONFIG.HEX_RADIUS;
      
      if (i === 0) {
        shape.moveTo(x, y);
      } else {
        shape.lineTo(x, y);
      }
    }
    shape.closePath();

    const geometry = new THREE.ExtrudeGeometry(shape, {
      depth: CONFIG.EXTRUDE_DEPTH,
      bevelEnabled: false
    });
    
    geometry.computeVertexNormals();

    const material = new THREE.MeshStandardMaterial({
      color,
      metalness: 0.2,
      roughness: 0.4,
      emissive: color,
      emissiveIntensity: 0,
    });

    return new THREE.Mesh(geometry, material);
  }

  static createMarker(position, face, data = {}) {
    const {
      id = state.nextId++,
      label = '',
      url = '',
      color = COLORS.PRIMARY
    } = data;

    const mesh = this.createHexMesh(color);
    const normal = GeometryHelper.getFaceNormal(face);
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, 1),
      normal.clone().normalize()
    );

    mesh.quaternion.copy(quaternion);
    mesh.position.copy(position);
    
    mesh.userData = {
      id,
      label,
      url,
      face,
      color
    };

    return mesh;
  }
}

// ========================================
// STORAGE MANAGER
// ========================================
class StorageManager {
  static save(markers) {
    // Saving disabled in client view - read only
    console.log('Client view: Saving is disabled');
    return false;
  }

  static load() {
    // Client view: Load from embedded data instead of localStorage
    if (typeof EMBEDDED_MARKERS !== 'undefined' && EMBEDDED_MARKERS && EMBEDDED_MARKERS.length > 0) {
      console.log('Client view: Loading from embedded data');
      return EMBEDDED_MARKERS;
    }
    
    // Fallback to localStorage if embedded data is empty (for testing)
    try {
      const raw = localStorage.getItem(CONFIG.STORAGE_KEY);
      if (!raw) return [];
      
      return JSON.parse(raw);
    } catch (error) {
      console.error('Failed to load units:', error);
      return [];
    }
  }

  static clear() {
    localStorage.removeItem(CONFIG.STORAGE_KEY);
  }
}

// ========================================
// AUDIO MANAGER
// ========================================
class AudioManager {
  constructor() {
    this.context = null;
  }

  init() {
    if (!this.context) {
      this.context = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  playClick(frequency = 880, volume = 0.002) {
    try {
      this.init();
      
      const oscillator = this.context.createOscillator();
      const gain = this.context.createGain();

      oscillator.type = 'sine';
      oscillator.frequency.value = frequency;
      gain.gain.value = volume;

      oscillator.connect(gain);
      gain.connect(this.context.destination);

      const now = this.context.currentTime;
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(volume, now + 0.002);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);

      oscillator.start(now);
      oscillator.stop(now + 0.14);
    } catch (error) {
      // Silent fail for audio
    }
  }

  playSuccess() {
    this.playClick(1200, 0.003);
  }

  playError() {
    this.playClick(400, 0.003);
  }
}

const audio = new AudioManager();

// ========================================
// UI MANAGER
// ========================================
class UIManager {
  constructor() {
    this.elements = {
      // Header
      toggleSidebar: document.getElementById('toggle-sidebar'),
      helpBtn: document.getElementById('help-btn'),
      settingsBtn: document.getElementById('settings-btn'),
      settingsMenu: document.getElementById('settings-menu'),
      
      // Sidebar
      sidebar: document.getElementById('sidebar'),
      searchBox: document.getElementById('search-box'),
      markerList: document.getElementById('marker-list'),
      
      // Control pad
      padUp: document.getElementById('pad-up'),
      padDown: document.getElementById('pad-down'),
      padLeft: document.getElementById('pad-left'),
      padRight: document.getElementById('pad-right'),
      
      // Actions - demo mode enabled
      addMarkerBtn: document.getElementById('add-marker-btn'),
      placeModeControls: document.getElementById('place-mode-controls'),
      confirmPlace: document.getElementById('confirm-place'),
      cancelPlace: document.getElementById('cancel-place'),
      
      // Editor - demo mode allows adding/editing (but not saving permanently)
      editorPanel: document.getElementById('editor-panel'),
      editorCollapsed: document.getElementById('editor-collapsed'),
      editorExpanded: document.getElementById('editor-expanded'),
      editorNameCollapsed: document.getElementById('editor-name-collapsed'),
      previewColorDot: document.getElementById('preview-color-dot'),
      previewId: document.getElementById('preview-id'),
      previewUrl: document.getElementById('preview-url'),
      visitUrlBtn: document.getElementById('visit-url-btn'),
      expandEditorBtn: document.getElementById('expand-editor-btn'),
      collapseEditorBtn: document.getElementById('collapse-editor-btn'),
      closeEditorCollapsedBtn: document.getElementById('close-editor-collapsed-btn'),
      // Expanded editor elements
      editorId: document.getElementById('editor-id'),
      editorName: document.getElementById('editor-name'),
      editorUrl: document.getElementById('editor-url'),
      editorColor: document.getElementById('editor-color'),
      editorColorHex: document.getElementById('editor-color-hex'),
      moveMarkerBtn: document.getElementById('move-marker-btn'),
      saveMarkerBtn: document.getElementById('save-marker-btn'),
      deleteMarkerBtn: document.getElementById('delete-marker-btn'),
      closeEditorBtn: document.getElementById('close-editor-btn'),
      
      // URL Viewer
      urlViewer: document.getElementById('url-viewer'),
      urlIframe: document.getElementById('url-iframe'),
      viewerUrlDisplay: document.getElementById('viewer-url-display'),
      backToCubeBtn: document.getElementById('back-to-cube'),
      openInNewTabBtn: document.getElementById('open-in-new-tab'),
      canvasContainer: document.getElementById('canvas-container'),
      
      // Settings
      gridToggle: document.getElementById('grid-toggle'),
      autoRotateToggle: document.getElementById('auto-rotate-toggle'),
      themeToggle: document.getElementById('theme-toggle'),
      
      // Tooltip & status
      tooltip: document.getElementById('tooltip'),
      statusIndicator: document.getElementById('status-indicator'),
      statusText: document.getElementById('status-text'),
      
      // Help
      helpOverlay: document.getElementById('help-overlay'),
      closeHelpBtn: document.getElementById('close-help-btn'),
    };

    this.setupEventListeners();
  }

  setupEventListeners() {
    // Header
    this.elements.toggleSidebar.addEventListener('click', () => this.toggleSidebar());
    this.elements.helpBtn.addEventListener('click', () => this.showHelp());
    this.elements.settingsBtn.addEventListener('click', () => this.toggleSettings());
    
    // Search
    this.elements.searchBox.addEventListener('input', (e) => {
      this.renderMarkerList(e.target.value);
    });
    
    // Settings
    this.elements.gridToggle.addEventListener('click', () => this.toggleGrid());
    this.elements.autoRotateToggle.addEventListener('click', () => this.toggleAutoRotate());
    this.elements.themeToggle.addEventListener('click', () => this.toggleTheme());
    
    // Export removed in client version
    
    // Help
    this.elements.closeHelpBtn.addEventListener('click', () => this.hideHelp());
    this.elements.helpOverlay.addEventListener('click', (e) => {
      if (e.target === this.elements.helpOverlay) this.hideHelp();
    });
    
    // Editor - demo mode (changes not saved permanently)
    this.elements.closeEditorBtn.addEventListener('click', () => this.closeEditor());
    this.elements.closeEditorCollapsedBtn.addEventListener('click', () => this.closeEditor());
    this.elements.expandEditorBtn.addEventListener('click', () => this.expandEditor());
    this.elements.collapseEditorBtn.addEventListener('click', () => this.collapseEditor());
    
    this.elements.editorColor.addEventListener('input', (e) => {
      this.elements.editorColorHex.textContent = e.target.value.toUpperCase();
      
      // Update ghost color in real-time when placing new marker or moving
      if ((state.placementMode || state.moveMode) && sceneManager.ghost) {
        const colorHex = e.target.value.replace('#', '');
        const color = parseInt(colorHex, 16);
        sceneManager.ghost.material.color.setHex(color);
      }
    });
    
    // Visit URL
    this.elements.visitUrlBtn.addEventListener('click', () => {
      const url = state.selectedMarker?.userData.url;
      if (url) {
        this.openURLViewer(url);
      }
    });
    
    // URL Viewer controls
    this.elements.backToCubeBtn.addEventListener('click', () => this.closeURLViewer());
    this.elements.openInNewTabBtn.addEventListener('click', () => {
      const url = this.elements.urlIframe.src;
      if (url && url !== 'about:blank') window.open(url, '_blank');
    });
    
    // Close panels on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        // If in URL viewer, go back
        if (this.elements.urlViewer.classList.contains('active')) {
          this.closeURLViewer();
          return;
        }
        // If in move mode, cancel the move
        if (state.moveMode) {
          interactionManager.cancelPlacement();
        }
        // Always try to close editor and help
        this.closeEditor();
        this.hideHelp();
        if (this.elements.settingsMenu.classList.contains('open')) {
          this.toggleSettings();
        }
      }
    });

    // Click outside to close settings
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#settings-dropdown') && 
          this.elements.settingsMenu.classList.contains('open')) {
        this.toggleSettings();
      }
    });
  }

  toggleSidebar() {
    state.sidebarCollapsed = !state.sidebarCollapsed;
    this.elements.sidebar.classList.toggle('collapsed', state.sidebarCollapsed);
  }

  toggleSettings() {
    const isOpen = this.elements.settingsMenu.classList.toggle('open');
    this.elements.settingsMenu.setAttribute('aria-hidden', !isOpen);
  }

  toggleGrid() {
    state.gridVisible = !state.gridVisible;
    this.elements.gridToggle.classList.toggle('active', state.gridVisible);
    this.elements.gridToggle.setAttribute('aria-checked', state.gridVisible);
    sceneManager.setGridVisible(state.gridVisible);
  }

  toggleAutoRotate() {
    state.autoRotate = !state.autoRotate;
    this.elements.autoRotateToggle.classList.toggle('active', state.autoRotate);
    this.elements.autoRotateToggle.setAttribute('aria-checked', state.autoRotate);
  }

  toggleTheme() {
    const isLight = document.body.classList.toggle('light-theme');
    this.elements.themeToggle.classList.toggle('active', isLight);
    this.elements.themeToggle.setAttribute('aria-checked', isLight);
    
    // Update Three.js scene
    if (sceneManager) {
      sceneManager.updateTheme(isLight);
    }
    
    // Save preference
    localStorage.setItem('hexcube_theme', isLight ? 'light' : 'dark');
  }

  exportMarkers() {
    const data = StorageManager.load();
    const json = JSON.stringify(data, null, 2);
    
    // Create download
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `hexcube-markers-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.showStatus('Markers exported successfully!');
  }

  showHelp() {
    this.elements.helpOverlay.classList.add('active');
  }

  hideHelp() {
    this.elements.helpOverlay.classList.remove('active');
  }

  renderMarkerList(filter = '') {
    const filtered = state.markers.filter(m => {
      const label = (m.userData.label || '').toLowerCase();
      return label.includes(filter.toLowerCase());
    });

    this.elements.markerList.innerHTML = '';

    filtered.forEach(marker => {
      const item = document.createElement('div');
      item.className = 'marker-item';
      item.setAttribute('role', 'listitem');
      
      const dot = document.createElement('div');
      dot.className = 'marker-dot';
      const colorHex = '#' + marker.userData.color.toString(16).padStart(6, '0');
      dot.style.backgroundColor = colorHex;
      dot.style.color = colorHex;
      
      const name = document.createElement('div');
      name.className = 'marker-name';
      name.textContent = marker.userData.label || '(unnamed)';
      
      const id = document.createElement('div');
      id.className = 'marker-id';
      id.textContent = `#${marker.userData.id}`;
      
      item.appendChild(dot);
      item.appendChild(name);
      item.appendChild(id);
      
      item.addEventListener('click', () => {
        this.openEditor(marker);
      });
      
      this.elements.markerList.appendChild(item);
    });
  }

  openEditor(marker) {
    state.selectedMarker = marker;
    
    this.elements.editorPanel.classList.add('open');
    this.elements.editorPanel.setAttribute('aria-hidden', 'false');
    
    // Set collapsed view data
    this.elements.editorNameCollapsed.textContent = marker.userData.label || '(unnamed)';
    this.elements.previewId.textContent = `#${marker.userData.id}`;
    
    const colorHex = '#' + marker.userData.color.toString(16).padStart(6, '0');
    this.elements.previewColorDot.style.backgroundColor = colorHex;
    this.elements.previewColorDot.style.color = colorHex;
    
    const url = marker.userData.url || '';
    this.elements.previewUrl.textContent = url || 'No URL set';
    this.elements.visitUrlBtn.disabled = !url;
    
    // Set expanded view data (for when user expands)
    this.elements.editorId.textContent = `#${marker.userData.id}`;
    this.elements.editorName.value = marker.userData.label || '';
    this.elements.editorUrl.value = url;
    this.elements.editorColor.value = colorHex;
    this.elements.editorColorHex.textContent = colorHex.toUpperCase();
    
    // Start in collapsed state
    this.collapseEditor();
    
    // Show/hide buttons based on mode
    if (state.placementMode) {
      // New marker being placed
      this.elements.moveMarkerBtn.style.display = 'none';
      this.elements.moveMarkerBtn.parentElement.style.display = 'none';
      this.elements.deleteMarkerBtn.style.display = 'none';
    } else if (state.moveMode) {
      // Marker being moved - hide move button, keep delete visible but disabled
      this.elements.moveMarkerBtn.style.display = 'none';
      this.elements.moveMarkerBtn.parentElement.style.display = 'none';
      this.elements.deleteMarkerBtn.style.display = '';
      this.elements.deleteMarkerBtn.disabled = false;
    } else {
      // Normal editing
      this.elements.moveMarkerBtn.style.display = '';
      this.elements.moveMarkerBtn.parentElement.style.display = '';
      this.elements.deleteMarkerBtn.style.display = '';
      this.elements.deleteMarkerBtn.disabled = false;
    }
  }

  openEditorForNewMarker() {
    // Create a temporary marker object to hold the new marker's data
    const tempMarker = {
      userData: {
        id: state.nextId,
        label: '',
        url: '',
        color: COLORS.PRIMARY
      }
    };
    
    state.selectedMarker = tempMarker;
    
    this.elements.editorPanel.classList.add('open');
    this.elements.editorPanel.setAttribute('aria-hidden', 'false');
    
    // For new markers, go straight to expanded view
    this.elements.editorCollapsed.style.display = 'none';
    this.elements.editorExpanded.style.display = 'flex';
    
    this.elements.editorId.textContent = `#${tempMarker.userData.id}`;
    this.elements.editorName.value = '';
    this.elements.editorUrl.value = '';
    this.elements.editorName.focus(); // Focus on name input
    
    const colorHex = '#' + COLORS.PRIMARY.toString(16).padStart(6, '0');
    this.elements.editorColor.value = colorHex;
    this.elements.editorColorHex.textContent = colorHex.toUpperCase();
    
    // Hide move and delete buttons when placing new marker
    this.elements.moveMarkerBtn.style.display = 'none';
    this.elements.moveMarkerBtn.parentElement.style.display = 'none';
    this.elements.deleteMarkerBtn.style.display = 'none';
  }

  closeEditor() {
    this.elements.editorPanel.classList.remove('open');
    this.elements.editorPanel.setAttribute('aria-hidden', 'true');
    state.selectedMarker = null;
    
    // Reset button visibility
    this.elements.moveMarkerBtn.style.display = '';
    this.elements.moveMarkerBtn.parentElement.style.display = '';
    this.elements.deleteMarkerBtn.style.display = '';
  }

  showStatus(text, duration = 2000) {
    this.elements.statusText.textContent = text;
    this.elements.statusIndicator.classList.add('active');
    
    setTimeout(() => {
      this.elements.statusIndicator.classList.remove('active');
    }, duration);
  }

  showTooltip(text, x, y) {
    this.elements.tooltip.textContent = text;
    this.elements.tooltip.style.display = 'block';
    this.elements.tooltip.style.left = (x + 14) + 'px';
    this.elements.tooltip.style.top = (y + 14) + 'px';
  }

  hideTooltip() {
    this.elements.tooltip.style.display = 'none';
  }

  expandEditor() {
    this.elements.editorCollapsed.style.display = 'none';
    this.elements.editorExpanded.style.display = 'flex';
  }

  collapseEditor() {
    this.elements.editorExpanded.style.display = 'none';
    this.elements.editorCollapsed.style.display = 'block';
  }

  openURLViewer(url) {
    // Validate URL
    try {
      new URL(url);
    } catch {
      // If no protocol, add https://
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        url = 'https://' + url;
      }
    }
    
    // Show URL viewer
    this.elements.urlViewer.classList.add('active');
    this.elements.urlViewer.setAttribute('aria-hidden', 'false');
    
    // Slide cube away
    this.elements.canvasContainer.classList.add('hidden');
    
    // Load URL
    this.elements.viewerUrlDisplay.textContent = url;
    this.elements.urlIframe.src = url;
    
    // Hide UI elements
    document.getElementById('header').style.display = 'none';
    document.getElementById('sidebar').style.display = 'none';
    document.getElementById('control-pad').style.display = 'none';
    document.getElementById('action-buttons').style.display = 'none';
    this.closeEditor();
  }

  closeURLViewer() {
    // Hide URL viewer
    this.elements.urlViewer.classList.remove('active');
    this.elements.urlViewer.setAttribute('aria-hidden', 'true');
    
    // Bring cube back
    this.elements.canvasContainer.classList.remove('hidden');
    
    // Clear iframe
    this.elements.urlIframe.src = 'about:blank';
    
    // Show UI elements
    document.getElementById('header').style.display = '';
    document.getElementById('sidebar').style.display = '';
    document.getElementById('control-pad').style.display = '';
    document.getElementById('action-buttons').style.display = '';
    
    // Reopen the marker panel if there was one selected
    if (state.selectedMarker && state.selectedMarker.position) {
      this.openEditor(state.selectedMarker);
    }
  }
}

// ========================================
// INTERACTION MANAGER
// ========================================
class InteractionManager {
  constructor(sceneManager, uiManager) {
    this.sceneManager = sceneManager;
    this.uiManager = uiManager;
    this.hoveredMarker = null;
    this.hoverTimer = null;

    this.setupEventListeners();
  }

  flipCube(direction) {
    // Don't rotate if in placement/move mode
    if (state.placementMode || state.moveMode) return;
    
    // Reset cube to flat frontal view on first arrow press
    if (!state.cubeAligned) {
      this.sceneManager.resetCubeRotation(() => {
        // After reset, perform the rotation
        this.sceneManager.rotateCubeToDirection(direction);
        audio.playClick(800, 0.002);
      });
      state.cubeAligned = true;
    } else {
      this.sceneManager.rotateCubeToDirection(direction);
      audio.playClick(800, 0.002);
    }
  }

  setupEventListeners() {
    const canvas = this.sceneManager.renderer.domElement;

    // Demo mode - allow adding/editing units (not saved permanently)

    // Add marker
    this.uiManager.elements.addMarkerBtn.addEventListener('click', () => {
      this.togglePlacementMode();
    });

    // Placement controls
    this.uiManager.elements.confirmPlace.addEventListener('click', () => {
      this.confirmPlacement();
    });

    this.uiManager.elements.cancelPlace.addEventListener('click', () => {
      this.cancelPlacement();
    });

    // Editor actions
    this.uiManager.elements.saveMarkerBtn.addEventListener('click', () => {
      this.saveMarker();
    });

    this.uiManager.elements.deleteMarkerBtn.addEventListener('click', () => {
      this.deleteMarker();
    });

    this.uiManager.elements.moveMarkerBtn.addEventListener('click', () => {
      this.startMoveMode();
    });

    // Canvas interactions
    canvas.addEventListener('pointermove', (e) => this.onPointerMove(e));
    canvas.addEventListener('pointerdown', (e) => this.onPointerDown(e));

    // Control pad
    this.setupControlPad();
    
    // Keyboard
    this.setupKeyboard();
  }

  setupControlPad() {
    this.uiManager.elements.padUp.addEventListener('click', () => this.flipCube('up'));
    this.uiManager.elements.padDown.addEventListener('click', () => this.flipCube('down'));
    this.uiManager.elements.padLeft.addEventListener('click', () => this.flipCube('left'));
    this.uiManager.elements.padRight.addEventListener('click', () => this.flipCube('right'));
  }

  setupKeyboard() {
    window.addEventListener('keydown', (e) => {
      // Check if user is typing in an input field
      const isTyping = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
      
      // Arrow keys - flip the cube
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        if (!isTyping && !state.placementMode && !state.moveMode) {
          e.preventDefault();
          
          // Map arrow keys to directions
          const directionMap = {
            'ArrowUp': 'up',
            'ArrowDown': 'down',
            'ArrowLeft': 'left',
            'ArrowRight': 'right'
          };
          
          this.flipCube(directionMap[e.key]);
        }
      }

      // Don't process shortcuts when typing in inputs
      if (isTyping) return;

      // Demo mode - allow shortcuts
      if (e.key === 'a' || e.key === 'A') {
        if (!state.placementMode && !state.moveMode) {
          this.togglePlacementMode();
        }
      }
      
      if (e.key === 'g' || e.key === 'G') {
        if (!state.placementMode && !state.moveMode) {
          this.uiManager.toggleGrid();
        }
      }
      
      if (e.key === 's' || e.key === 'S') {
        if (!state.placementMode && !state.moveMode) {
          this.uiManager.toggleSidebar();
        }
      }
      
      // Help always works
      if (e.key === '?') {
        this.uiManager.showHelp();
      }
    });
  }

  // updateRotationFromKeys removed - no longer needed with face flipping

  togglePlacementMode() {
    state.setPlacementMode(!state.placementMode);
    
    if (state.placementMode) {
      this.sceneManager.ghost.visible = false;
      this.uiManager.elements.placeModeControls.classList.remove('active');
      this.uiManager.elements.addMarkerBtn.textContent = 'Placing...';
      this.sceneManager.renderer.domElement.style.cursor = 'crosshair';
      this.uiManager.showStatus('Hover a hex position and click to lock it');
      
      // Disable control pad visually
      document.getElementById('control-pad').style.opacity = '0.3';
      document.getElementById('control-pad').style.pointerEvents = 'none';
    } else {
      this.cancelPlacement();
    }
  }

  cancelPlacement() {
    state.setPlacementMode(false);
    state.setMoveMode(false);
    state.placementLocked = false;
    this.sceneManager.ghost.visible = false;
    this.uiManager.elements.placeModeControls.classList.remove('active');
    this.uiManager.elements.addMarkerBtn.textContent = '+ Add Marker';
    this.sceneManager.renderer.domElement.style.cursor = '';
    
    // Re-enable control pad
    document.getElementById('control-pad').style.opacity = '1';
    document.getElementById('control-pad').style.pointerEvents = '';
  }

  confirmPlacement() {
    if (!state.selectedPlacement || !state.placementLocked) return;

    // Only handle new marker placement here (move is now automatic)
    if (state.placementMode) {
      // Add new marker - get details from editor
      const label = this.uiManager.elements.editorName.value.trim();
      const url = this.uiManager.elements.editorUrl.value.trim();
      const colorHex = this.uiManager.elements.editorColor.value.replace('#', '');
      const color = parseInt(colorHex, 16);
      
      const marker = MarkerFactory.createMarker(
        state.selectedPlacement.center,
        state.selectedPlacement.face,
        {
          label,
          url,
          color
        }
      );
      
      this.sceneManager.cube.add(marker);
      state.addMarker(marker);
      
      StorageManager.save(state.markers);
      this.uiManager.renderMarkerList();
      this.uiManager.showStatus('Marker added');
      audio.playSuccess();
      
      this.animateMarker(marker);
      this.sceneManager.ghost.material.opacity = 0.3; // Reset ghost opacity
      this.cancelPlacement();
      this.uiManager.closeEditor();
    }
  }

  startMoveMode() {
    if (!state.selectedMarker) return;
    
    state.setMoveMode(true);
    state.setPlacementMode(false);
    state.placementLocked = false;
    
    this.uiManager.elements.placeModeControls.classList.remove('active');
    this.sceneManager.renderer.domElement.style.cursor = 'crosshair';
    this.sceneManager.ghost.material.opacity = 0.3; // Reset ghost opacity
    
    // Update ghost to match marker being moved
    const colorHex = this.uiManager.elements.editorColor.value.replace('#', '');
    const color = parseInt(colorHex, 16);
    this.sceneManager.ghost.material.color.setHex(color);
    
    this.uiManager.showStatus('Click on a hex position to move marker there');
    
    // Disable control pad visually
    document.getElementById('control-pad').style.opacity = '0.3';
    document.getElementById('control-pad').style.pointerEvents = 'none';
  }

  saveMarker() {
    if (!state.selectedMarker) return;

    state.selectedMarker.userData.label = this.uiManager.elements.editorName.value.trim();
    state.selectedMarker.userData.url = this.uiManager.elements.editorUrl.value.trim();
    
    const colorHex = this.uiManager.elements.editorColor.value.replace('#', '');
    const colorNum = parseInt(colorHex, 16);
    state.selectedMarker.userData.color = colorNum;
    state.selectedMarker.material.color.setHex(colorNum);
    state.selectedMarker.material.emissive.setHex(colorNum);

    StorageManager.save(state.markers);
    this.uiManager.renderMarkerList();
    this.uiManager.showStatus('Marker saved');
    audio.playSuccess();
    this.uiManager.closeEditor();
  }

  deleteMarker() {
    if (!state.selectedMarker) return;

    const label = state.selectedMarker.userData.label || '(unnamed)';
    if (!confirm(`Delete marker "${label}"?`)) return;

    this.sceneManager.cube.remove(state.selectedMarker);
    state.removeMarker(state.selectedMarker);
    
    StorageManager.save(state.markers);
    this.uiManager.renderMarkerList();
    this.uiManager.showStatus('Marker deleted');
    audio.playClick(400);
    this.uiManager.closeEditor();
  }

  onPointerMove(e) {
    const rect = this.sceneManager.renderer.domElement.getBoundingClientRect();
    this.sceneManager.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    this.sceneManager.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    // Handle placement mode - only update ghost if not locked
    if ((state.placementMode || state.moveMode) && !state.placementLocked) {
      this.updateGhostPosition();
      return;
    }

    // Handle marker hover (only when not in placement mode)
    if (!state.placementMode && !state.moveMode) {
      this.handleMarkerHover(e);
    }
  }

  updateGhostPosition() {
    this.sceneManager.raycaster.setFromCamera(
      this.sceneManager.mouse,
      this.sceneManager.camera
    );

    const intersects = this.sceneManager.raycaster.intersectObject(
      this.sceneManager.cube,
      false
    );

    if (intersects.length === 0) {
      this.sceneManager.ghost.visible = false;
      state.selectedPlacement = null;
      return;
    }

    const hit = intersects[0];
    const localPoint = this.sceneManager.cube.worldToLocal(hit.point.clone());
    const face = GeometryHelper.findFaceFromLocal(localPoint);
    const center = GeometryHelper.findNearestCenter(face, localPoint);

    if (!center) {
      this.sceneManager.ghost.visible = false;
      state.selectedPlacement = null;
      return;
    }

    this.sceneManager.ghost.visible = true;
    this.sceneManager.ghost.position.copy(center);
    
    const normal = GeometryHelper.getFaceNormal(face);
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, 1),
      normal.clone().normalize()
    );
    this.sceneManager.ghost.quaternion.copy(quaternion);

    state.selectedPlacement = { center: center.clone(), face };
  }

  handleMarkerHover(e) {
    this.sceneManager.raycaster.setFromCamera(
      this.sceneManager.mouse,
      this.sceneManager.camera
    );

    const intersects = this.sceneManager.raycaster.intersectObjects(
      state.markers,
      true
    );

    if (intersects.length > 0) {
      const marker = intersects[0].object;
      
      if (this.hoveredMarker !== marker) {
        this.clearHover();
        
        this.hoveredMarker = marker;
        this.hoveredMarker.scale.set(1.1, 1.1, 1.1);
        this.hoveredMarker.material.emissiveIntensity = 0.3;
        
        // Schedule editor open
        clearTimeout(this.hoverTimer);
        this.hoverTimer = setTimeout(() => {
          this.uiManager.openEditor(marker);
        }, CONFIG.HOVER_DELAY);
      }
      
      const label = marker.userData.label || `Marker #${marker.userData.id}`;
      this.uiManager.showTooltip(label, e.clientX, e.clientY);
    } else {
      this.clearHover();
      this.uiManager.hideTooltip();
    }
  }

  clearHover() {
    if (this.hoveredMarker) {
      this.hoveredMarker.scale.set(1, 1, 1);
      this.hoveredMarker.material.emissiveIntensity = 0;
      this.hoveredMarker = null;
    }
    clearTimeout(this.hoverTimer);
  }

  onPointerDown(e) {
    // If in placement mode and not yet locked, clicking locks the ghost position
    if (state.placementMode && !state.placementLocked) {
      if (state.selectedPlacement) {
        state.placementLocked = true;
        this.sceneManager.ghost.material.opacity = 0.6; // Make ghost more visible when locked
        this.uiManager.elements.placeModeControls.classList.add('active');
        audio.playClick(1000);
        
        // New marker placement
        this.uiManager.showStatus('Edit details and confirm to place marker');
        this.uiManager.openEditorForNewMarker();
      }
      return;
    }

    // If in move mode and not yet locked, clicking immediately moves the marker
    if (state.moveMode && !state.placementLocked && state.selectedPlacement) {
      if (state.selectedMarker && state.selectedMarker.position) {
        // Move existing marker immediately
        state.selectedMarker.position.copy(state.selectedPlacement.center);
        state.selectedMarker.userData.face = state.selectedPlacement.face;
        this.updateMarkerOrientation(state.selectedMarker);
        
        StorageManager.save(state.markers);
        this.uiManager.renderMarkerList();
        this.uiManager.showStatus('Marker moved');
        audio.playSuccess();
        
        this.animateMarker(state.selectedMarker);
        this.sceneManager.ghost.material.opacity = 0.3; // Reset ghost opacity
        this.cancelPlacement();
        // Keep editor open so user can continue editing if they want
      }
      return;
    }

    // If already locked in placement mode, ignore clicks (must use confirm/cancel buttons)
    if (state.placementLocked) {
      return;
    }

    // Check if clicked on marker (only when not in placement mode)
    if (!state.placementMode && !state.moveMode) {
      this.sceneManager.raycaster.setFromCamera(
        this.sceneManager.mouse,
        this.sceneManager.camera
      );

      const intersects = this.sceneManager.raycaster.intersectObjects(
        state.markers,
        true
      );

      if (intersects.length > 0) {
        const marker = intersects[0].object;
        this.uiManager.openEditor(marker);
        audio.playClick();
      }
    }
  }

  updateMarkerOrientation(marker) {
    const normal = GeometryHelper.getFaceNormal(marker.userData.face);
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, 1),
      normal.clone().normalize()
    );
    marker.quaternion.copy(quaternion);
  }

  animateMarker(marker) {
    const startTime = performance.now();
    const duration = 300;
    const originalScale = marker.scale.clone();

    const animate = () => {
      const elapsed = performance.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      const scale = progress < 0.5
        ? 1 + 0.2 * (progress / 0.5)
        : 1.2 - 0.2 * ((progress - 0.5) / 0.5);
      
      marker.scale.set(scale, scale, scale);

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        marker.scale.copy(originalScale);
      }
    };

    animate();
  }
}

// ========================================
// ANIMATION LOOP
// ========================================
class AnimationLoop {
  constructor(sceneManager) {
    this.sceneManager = sceneManager;
    this.lastTime = performance.now();
  }

  start() {
    this.animate();
  }

  animate(now = performance.now()) {
    requestAnimationFrame(() => this.animate());

    const deltaTime = Math.min(0.05, (now - this.lastTime) / 1000);
    this.lastTime = now;

    // Apply rotation
    if (Math.abs(state.rotationState.x) > 0 || Math.abs(state.rotationState.y) > 0) {
      this.sceneManager.cube.rotation.x += state.rotationState.x * deltaTime;
      this.sceneManager.cube.rotation.y += state.rotationState.y * deltaTime;
      this.sceneManager.cube.updateMatrixWorld(true);
    }

    // Auto-rotate
    if (state.autoRotate) {
      this.sceneManager.cube.rotation.y += CONFIG.AUTO_ROTATE_SPEED;
      this.sceneManager.cube.updateMatrixWorld(true);
    }

    this.sceneManager.controls.update();
    this.sceneManager.render();
  }
}

// ========================================
// INITIALIZATION
// ========================================
function loadSavedMarkers() {
  const savedData = StorageManager.load();
  
  savedData.forEach(data => {
    const position = new THREE.Vector3(data.x, data.y, data.z);
    const marker = MarkerFactory.createMarker(position, data.face, data);
    
    sceneManager.cube.add(marker);
    state.addMarker(marker);
  });
}

// Initialize app
const sceneManager = new SceneManager();
const uiManager = new UIManager();
const interactionManager = new InteractionManager(sceneManager, uiManager);
const animationLoop = new AnimationLoop(sceneManager);

// Load saved theme preference
const savedTheme = localStorage.getItem('hexcube_theme');
if (savedTheme === 'light') {
  document.body.classList.add('light-theme');
  uiManager.elements.themeToggle.classList.add('active');
  uiManager.elements.themeToggle.setAttribute('aria-checked', 'true');
  sceneManager.updateTheme(true);
}

// Load saved markers
loadSavedMarkers();
uiManager.renderMarkerList();

// Start animation
animationLoop.start();

// Show welcome message
setTimeout(() => {
  uiManager.showStatus('HexCube loaded • Press ? for help', 3000);
}, 500);

// Expose for debugging
window.__HexCube = {
  state,
  sceneManager,
  uiManager,
  interactionManager,
  GeometryHelper,
  MarkerFactory,
  StorageManager
};

console.log('%c🎲 HexCube Ready', 'font-size: 20px; font-weight: bold; color: #00D9FF;');
console.log('Access debug tools via window.__HexCube');
</script>

</body>
</html>
